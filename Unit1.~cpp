//---------------------------------------------------------------------------

#include <vcl.h>
#pragma hdrstop

#include "Unit1.h"
#include <fstream.h>
#include<iostream.h>
#include<sysutils.hpp>

//---------------------------------------------------------------------------
#pragma package(smart_init)
#pragma resource "*.dfm"
TForm1 *Form1;
int dlina_zvuk;
// определяем массив в который будет заноситься конкатенация номеров максимальных и минимальных
// элементов массива
// 0-я строка максимумы, 1-я строка - минимумы
AnsiString mass_konkat[17][2];
// массив элементов среди которых будут искаться минимумы и максимумы
short int mass_chislo[9][9], u=1;
//---------------------------------------------------------------------------
__fastcall TForm1::TForm1(TComponent* Owner)
        : TForm(Owner)
{
}
//---------------------------------------------------------------------------


void __fastcall TForm1::FormShow(TObject *Sender)
{
// вывод индексов элементов матрицы в гриде
for(int i=1; i<10;i++)    { Str->Cells[0][i]=i; Str1->Cells[0][i]=i; }
for(int j=1; j<10;j++)    { Str->Cells[j][0]=j; Str1->Cells[j][0]=j; }
// передаем фокус в грид для его заполнения
Str->SetFocus();
for(int i=1; i<18;i++)    Str2->Cells[i][0]=i;
for(int i=1; i<3;i++)     Str2->Cells[0][i]=i;
// заремарено автоматическое заполнение первоначальной матриці
/*for(int i=0; i<10;i++)
for(int j=0; j<10;j++)
    mass_chislo[i][j]=i*j+1;
for(int i=0; i<9;i++)
    for(int j=0; j<9;j++)
        Str->Cells[j+1][i+1]=StrToInt(mass_chislo[i][j]);*/
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button1Click(TObject *Sender)
{
// вносим в матрицу значения ячеек грида(таблицы)
for(int i=0; i<9;i++)
    for(int j=0; j<9;j++)
        mass_chislo[i][j]=StrToInt(Str->Cells[j+1][i+1]);

// открываем файл для записи (если его нет - создается, если есть - затирается)
ofstream outfile("ids272.inp");
if(!outfile)
   {
   // если не можем создать файл - сообщение
   ShowMessage("Не могу создать файл!");
   Abort();
   }
// выводим в файл элементы i-й строки матрицы разделенные в файле пробелом,
// последним элементом является символ конца строки endl
for(int i=0; i<9; i++)
    outfile<<mass_chislo[i][0]<<' '<<mass_chislo[i][1]<<' '<<mass_chislo[i][2]<<' '<<mass_chislo[i][3]<<' '<<mass_chislo[i][4]<<' '<<mass_chislo[i][5]<<' '<<mass_chislo[i][6]<<' '<<mass_chislo[i][7]<<' '<<mass_chislo[i][8]<<endl;
// закрываем файл
outfile.close();
// открываем файл для чтения
ifstream infile("ids272.inp");
if(!infile)
   {
   ShowMessage("Не могу открыть файл!");
   Abort();
   }
// вносим значения из файла в матрицу
for(int i=0; i<9;i++)
    infile>>mass_chislo[i][0]>>mass_chislo[i][1]>>mass_chislo[i][2]>>mass_chislo[i][3]>>mass_chislo[i][4]>>mass_chislo[i][5]>>mass_chislo[i][6]>>mass_chislo[i][7]>>mass_chislo[i][8];
// закрываем файл
infile.close();
// вносим значения матрицы в строковую таблицу Str1
for(int i=0; i<9;i++)
    for(int j=0; j<9;j++)
        Str1->Cells[j+1][i+1]=mass_chislo[i][j];
}
//---------------------------------------------------------------------------
void __fastcall TForm1::Button2Click(TObject *Sender)
{
// объявление переменных для запоминания промежуточных значений максимумов и минимумов
short int max2, min2, max1, min1, rez;

// матрица двумерная: следовательно для перебора всех элементов используем
// двойной цикл
// внешний цикл - перебираем столбцы матрицы
for(int t=0; t<9; t++)
    {
    //вложенный цикл - перебираем строки диагонали
    for(int y=0; y<t+1; y++)
        {
        // хитрые вычисления нужны для того: чтобы не писать второй раз двойные циклы для вычисления
        // диагонале, которые будут идти после побочной (побочная идет с 8:0 элемента по 0:8),
        // т.е. за один проход делаем два действия. исключение - побочная диагонль, при т=8 вычисления
        // только с побочной диагональю
        if(y == 0)
            {
            // определяем первоначальное значение максимума и минимума в диагонали c 0 по 8 включительно
            max1=mass_chislo[t][y];
            min1=mass_chislo[t][y];
            // заполняем конкатенацию номеров соответствующего элемента в массив
            // 0-я строка - максимумы; 1-я минимумы
            mass_konkat[t][0]=IntToStr(t)+":"+IntToStr(y);
            mass_konkat[t][1]=IntToStr(t)+":"+IntToStr(y);
            // определяем первоначальное значение максимума и минимума в диагонали c 16 по 9 включительно
            // y-t+8  - расчет номера столбца, 8-y - номер строки элемента в диагонали
            max2=mass_chislo[y-t+8][8-y];
            min2=mass_chislo[y-t+8][8-y];
            // заполняем конкатенацию(склеивание строк. в нашем случае строка-номер элемента в матрице)
            // номеров соответствующего элемента в массив
            // 0-я строка - максимумы; 1-я минимумы
            mass_konkat[16-t][0]=IntToStr(y-t+8)+":"+IntToStr(8-y);
            mass_konkat[16-t][1]=IntToStr(y-t+8)+":"+IntToStr(8-y);
            }
        else
           {
           // если первоначальный (или запомненный) максимум менше текущего значения элемента
           if(max1 < mass_chislo[t-y][y])
               {
               // то меняем значение максимума для диагоналей с 0 по 8 (слева направо)
               max1=mass_chislo[t-y][y];
               // и меняем соответствующее значение конкатенации
               mass_konkat[t][0]=IntToStr(t-y)+":"+IntToStr(y);
               }
           // аналогичное вычисление для минимума
           if(min1 > mass_chislo[t-y][y])
               {
               min1=mass_chislo[t-y][y];
               mass_konkat[t][1]=IntToStr(t-y)+":"+IntToStr(y);
               }
           // и аналогичные расчеты для максимумов и минимумов диагоналей с 9 по 16
           if(t != 8)
               {
               if(max2 < mass_chislo[y-t+8][8-y])
                   {
                   max2=mass_chislo[y-t+8][8-y];
                   mass_konkat[16-t][0]=IntToStr(y-t+8)+":"+IntToStr(8-y);
                   }
               if(min2 > mass_chislo[y-t+8][8-y])
                   {
                   min2=mass_chislo[y-t+8][8-y];
                   mass_konkat[16-t][1]=IntToStr(y-t+8)+":"+IntToStr(8-y);
                   }
               }
           }
        }
    }
// выводим значения маотрицы результатов в грид Str2
for(int t=0; t<17; t++)
    for(int y=0; y<2; y++)
        Str2->Cells[t+1][y+1]=mass_konkat[t][y];

ofstream outfile("ids272out.inp");
if(!outfile)
   {
   ShowMessage("Не могу создать файл!");
   Abort();
   }
// выводим результаты операций в файл
for(int j=0; j<2; j++)
    for(int i=0; i<17; i++)
        {
        if (i == 16)
           // если записываемые элемент является последним в строке - даем символ конец строки в файле
           outfile<<mass_konkat[i][j].c_str()<<endl;
        else
           outfile<<mass_konkat[i][j].c_str()<<' ';
        }
outfile.close();

}
//---------------------------------------------------------------------------
void __fastcall TForm1::FormClose(TObject *Sender, TCloseAction &Action)
{
try
    {
    Beep(100,StrToInt(ParamStr(1)));
    }
catch(...)
    {
    ShowMessage("Не задали параметр или его чмсловое значение");
    }
}
//---------------------------------------------------------------------------
